---
weight: 16
title: "RPC"
---


include: [co/rpc.h](https://github.com/idealvin/co/blob/master/include/co/rpc.h).


co/rpc is a high-performance RPC framework similar to [grpc](https://github.com/grpc/grpc), it uses **JSON** as the data exchange format, which is different from binary protocols such as protobuf.




## rpc::Service

````cpp
class Service {
   public:
     Service() = default;
     virtual ~Service() = default;

     typedef std::function<void(Json&, Json&)> Fun;

     virtual const char* name() const = 0;
     virtual const co::map<const char*, Fun>& methods() const = 0;
};
````

- This class is a pure interface, which represents a service. A RPC server may have multiple services.
- `name()` returns the service name, like "HelloWorld".
- `methods()` returns all the RPC methods provided by the Service class.




## rpc::Server

### Server::Server

```cpp
Server();
```

- The default constructor, users do not need to care.



### Server::add_service

```cpp
Server& add_service(rpc::Service* s);
Server& add_service(const std::shared_ptr<rpc::Service>& s);
```

- Add a service, the parameter s must be dynamically created with operator new.
- Users can call this method multiple times to add multiple services, and **different services must have different names**.



### Server::start

```cpp
void start(
    const char* ip, int port,
    const char* url='/',
    const char* key=0, const char* ca=0
);
```

- Start the RPC server, this method will not block the current thread.
- The parameter ip is the server ip, which can be an IPv4 or IPv6 address, and the parameter port is the server port. 
- The parameter url is the url of the HTTP service, and must start with `/`.
- The parameter **key** is path of a **PEM**file which stores the SSL private key, and the parameter **ca** is path of a PEM file which stores the SSL certificate. They are NULL by default, and SSL is disabled.
- Starting from v3.0, the server no longer depends on the `rpc::Server` object after startup.



### Server::exit

```cpp
void exit();
```

- Added since v2.0.2.
- Exit the RPC server, close the listening socket, and no longer receive new connections.
- Since v3.0, after the RPC server exits, previously established connections will be reset in the future.




## RPC server example

### Define a proto file

```cpp
// hello_world.proto

package xx

service HelloWorld {
    hello,
    world,
}
```

- The above is a simple proto file, `//` is for comments.
- **package xx** specifies the package name. In C++, it means that the code is generated into a namespace. You can use package xx.yy.zz to generate nested namespaces.
- **service HelloWorld** defines a service class that inherits from **rpc::Service**, and its name is `"HelloWorld"`. The service class provides two RPC methods, hello and world.
- **A proto file can define only one service.** In the proto file, the contents after the service definition will be ignored.



### Generate code for RPC service

[gen](https://github.com/idealvin/co/tree/master/gen) is the RPC code generator provided by co, which can be used to generate code for RPC service.

```bash
xmake -b gen             # build gen
cp gen /usr/local/bin    # put gen in the /usr/local/bin directory
gen hello_world.proto    # Generate code
gen *.proto              # Batch generation
```

The file generated for hello_world.proto is hello_world.h:

```cpp
// Autogenerated.
// DO NOT EDIT. All changes will be undone.
#pragma once

#include "co/rpc.h"

namespace xx {

class HelloWorld : public rpc::Service {
  public:
    typedef std::function<void(Json&, Json&)> Fun;

    HelloWorld() {
        using std::placeholders::_1;
        using std::placeholders::_2;
        _methods["HelloWorld.hello"] = std::bind(&HelloWorld::hello, this, _1, _2);
        _methods["HelloWorld.world"] = std::bind(&HelloWorld::world, this, _1, _2);
    }

    virtual ~HelloWorld() {}

    virtual const char* name() const {
        return "HelloWorld";
    }

    virtual const co::map<const char*, Fun>& methods() const {
        return _methods;
    }

    virtual void hello(Json& req, Json& res) = 0;

    virtual void world(Json& req, Json& res) = 0;

  private:
    co::map<const char*, Fun> _methods;
};

} // xx
```

- As you can see, the HelloWorld class inherits from rpc::Service, and it has already implemented name() and methods() in rpc::Service.
- Users only need to inherit the HelloWorld class and implement the hello and world methods.



### Implement the RPC service

```cpp
#include "hello_world.h"

namespace xx {

class HelloWorldImpl : public HelloWorld {
  public:
    HelloWorldImpl() = default;
    virtual ~HelloWorldImpl() = default;

    virtual void hello(Json& req, Json& res) {
        res = {
            { "result", {
                { "hello", 23 }
            }}
        };
    }

    virtual void world(Json& req, Json& res) {
        res = {
            { "error", "not supported"}
        };
    }
};

} // xx
```

- The above is just a very simple example. In actual applications, it is generally necessary to perform corresponding business processing according to the parameters in req, and then fill in res.



### Start RPC server

```cpp
int main(int argc, char** argv) {
    flag::init(argc, argv);

    rpc::Server s;
    s.add_service(new xx::HelloWorldImpl);

    // without ssl
    s.start("127.0.0.1", 7788, "/xx");

    // with ssl
    //s.start("127.0.0.1", 7788, "/xx", "privkey.pem", "certificate.pem");

    for (;;) sleep::sec(80000);
    return 0;
}
```

- Before starting the server, we must call add_service() to add the service.
- The `start()` method will not block the current thread, so we need to write a for loop to prevent the main function from exiting directly.



### Call RPC service with curl

In v3.0, co/rpc supports HTTP protocol, so RPC service can be called with the `curl` command:

```bash
curl http://127.0.0.1:7788/xx --request POST --data '{"api":"ping"}'
curl http://127.0.0.1:7788/xx --request POST --data '{"api":"HelloWorld.hello"}'
```

- The above use `curl` to send a POST request to the RPC server, the parameter is a JSON string, and a `"api"` field must be provided to indicate the RPC method to be called.

- `"ping"` is a built-in method of the RPC framework, generally used for testing or sending heartbeats.

- `/xx` in the url should be consistent with the url specified when the RPC server is started.




## rpc::Client

### Client::Client

```cpp
Client(const char* ip, int port, bool use_ssl=false);
Client(const Client& c);
```

- Constructor. 
- The first one, the parameter ip is the ip of the server, which can be a domain name, IPv4 or IPv6 address; the parameter port is the server port; the parameter use_ssl indicates whether to enable SSL transmission, the default is false, and SSL is disabled.
- When rpc::Client was constructed, the connection is not established immediately.



### Client::~Client

```cpp
Client::~Client();
```

- Destructor, close the internal connection.



### Client::call

```cpp
void call(const Json& req, Json& res);
```

- Perform a RPC request, it must be called in the coroutine.
- The parameter `req` must contain the `"api"` field, its value is generally in the form of `"service.method"`.
- The parameter `res` is the response result of the RPC request.
- If the RPC request is not sent, or no response from the server is received, res will not be filled.
- This method checks the connection status before sending the RPC request, and establishes the connection first if it is not connected.



### Client::close

```cpp
void close();
```

- Close the connection, it is safe to call this function multiple times.



### Client::ping

```cpp
void ping();
```

- Send a `ping` request to the server, generally used for testing or sending heartbeats.




## RPC client example

### Use the rpc::Client directly

```cpp
DEF_bool(use_ssl, false, "use ssl if true");
DEF_int32(n, 3, "request num");

void client_fun() {
    rpc::Client c("127.0.0.1", 7788, FLG_use_ssl);

    for (int i = 0; i < FLG_n; ++i) {
        Json req = {
            {"api", "HelloWorld.hello"}
        };
        Json res;
        c.call(req, res);
        co::sleep(1000);
    }

    c.close();
}

go(client_fun);
```

- In the above example, the client sends an RPC request to the server every 1 second.



### Use connection pool co::Pool

When a client needs to establish a large number of connections, `co::Pool` can be used to manage these connections.

```cpp
std::unique_ptr<rpc::Client> proto;

co::Pool pool(
    []() { return (void*) new rpc::Client(*proto); },
    [](void* p) { delete (rpc::Client*) p; }
);

void client_fun() {
    co::PoolGuard<rpc::Client> c(pool);

    while (true) {
        c->ping();
        co::sleep(3000);
    }
}

proto.reset(new rpc::Client("127.0.0.1", 7788));

for (int i = 0; i < 8; ++i) {
    go(client_fun);
}
```


- In the above example, co::Pool is used to store the clients, and multiple coroutines can share these clients.
- co::PoolGuard automatically pops an idle client from co::Pool when it is created, and automatically puts the client back into co::Pool when it is destructed.
- The ccb of co::Pool uses copy construction to copy a client from proto.




## Config items

co/rpc uses [co/flag](../../flag/) to define config items. The flags defined in co/rpc are listed below.


### rpc_conn_idle_sec

```cpp
DEF_int32(rpc_conn_idle_sec, 180, "#2 connection may be closed if no data...");
```

- Timeout in **seconds** for idle connections in rpc::Server. If a connection does not receive any data within this time, the server may close the connection.



### rpc_conn_timeout

```cpp
DEF_int32(rpc_conn_timeout, 3000, "#2 connect timeout in ms");
```

- Connect timeout in milliseconds for rpc::Client.



### rpc_log

```cpp
DEF_bool(rpc_log, true, "#2 enable rpc log if true");
```

- Whether to print RPC logs, the default is true, rpc::Server and rpc::Client will print RPC requests and responses.



### rpc_max_idle_conn

```cpp
DEF_int32(rpc_max_idle_conn, 128, "#2 max idle connections");
```

- Maximum number of idle connections for rpc::Server. The default is 128. When this number is exceeded, the server will close some idle connections.



### rpc_max_msg_size

```cpp
DEF_int32(rpc_max_msg_size, 8 << 20, "#2 max size of rpc message, default: 8M");
```

- The maximum length of RPC messages, the default is 8M.



### rpc_recv_timeout

```cpp
DEF_int32(rpc_recv_timeout, 3000, "#2 recv timeout in ms");
```

- RPC recv timeout in milliseconds.



### rpc_send_timeout

```cpp
DEF_int32(rpc_send_timeout, 3000, "#2 send timeout in ms");
```

- RPC send timeout in milliseconds.
