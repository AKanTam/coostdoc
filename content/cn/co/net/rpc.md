---
weight: 16
title: "RPC"
---


include: [co/rpc.h](https://github.com/idealvin/coost/blob/master/include/co/rpc.h).


co/rpc 是一个类似 [grpc](https://github.com/grpc/grpc) 的高性能 RPC 框架，它内部使用 **JSON** 格式传输数据，而不是 protobuf 等二进制协议。从 v3.0 开始，co/rpc 同时支持 HTTP 协议，可以用 HTTP 的 POST 方法调用 rpc 服务。




## rpc::Service

```cpp
class Service {
  public:
    Service() = default;
    virtual ~Service() = default;

    typedef std::function<void(Json&, Json&)> Fun;

    virtual const char* name() const = 0;
    virtual const co::map<const char*, Fun>& methods() const = 0;
};
```

- 接口类，它表示一个 service，一个 RPC server 中可以包含多个 service。
- `name()` 返回 service 名，如 "HelloWorld"。
- `methods()` 返回该 Service 类提供的所有 RPC 方法。




## rpc::Server

### Server::Server

```cpp
Server();
```

- 默认构造函数，用户不需要关心。



### Server::add_service

```cpp
Server& add_service(rpc::Service* s);
Server& add_service(const std::shared_ptr<rpc::Service>& s);
```

- 添加 service，参数 s 必须是用 operator new 动态创建的。
- 用户可以多次调用此方法，添加多个 service，不同 service 必须有不同的名字。



### Server::start

```cpp
void start(
    const char* ip, int port,
    const char* url='/',
    const char* key=0, const char* ca=0
);
```

- 启动 RPC server，此方法不会阻塞当前线程。
- 参数 ip 是服务器 ip，可以是 IPv4 或 IPv6 地址，参数 port 是服务器端口。
- 参数 url 是 HTTP 服务的 url，必须以 `/` 开头。
- 参数 key 是存放 SSL private key 的 PEM 文件路径，参数 ca 是存放 SSL 证书的 PEM 文件路径，默认 key 和 ca 是 NULL，不启用 SSL。
- 从 v3.0 开始，server 启动后就不再依赖于 `rpc::Server` 对象。



### Server::exit

```cpp
void exit();
```

- v2.0.3 新增。
- 退出 RPC server，关闭 listening socket，不再接收新的连接。
- 从 v3.0 开始，RPC server 退出后，之前已经建立的连接将在未来被重置。




## RPC server 示例

### 定义 proto 文件

```cpp
// hello_world.proto

package xx

service HelloWorld {
    hello,
    world,
}
```

- 上面是一个简单的 proto 文件，`//` 表示注释。
- **package xx** 指定包名，在 C++ 中表示将代码生成到命名空间 xx 中，可以用 package xx.yy.zz 生成嵌套命名空间。
- **service HelloWorld** 定义一个继承 rpc::Service 的 service 类，它的名字是 `"HelloWorld"`。该 service 提供 hello, world 两个 RPC 方法。
- 可以看到，co/rpc 的 proto 文件比 protobuf 简单得多。由于 **RPC 请求及响应都是 JSON，不需要定义各种结构体**。
- 一个 proto 文件只能定义一个 service。proto 文件中，在 service 定义后面的内容都会被忽略。



### 生成 service 代码

[gen](https://github.com/idealvin/coost/tree/master/gen) 是 co 提供的 RPC 代码生成器，它可以生成 service 相关代码。

```bash
xmake -b gen             # 构建 gen
cp gen /usr/local/bin    # 将 gen 放到 /usr/local/bin 目录
gen hello_world.proto    # 生成代码
gen *.proto              # 批量生成
```

hello_world.proto 协议文件，会生成如下的 hello_world.h：

```cpp
// Autogenerated.
// DO NOT EDIT. All changes will be undone.
#pragma once

#include "co/rpc.h"

namespace xx {

class HelloWorld : public rpc::Service {
  public:
    typedef std::function<void(Json&, Json&)> Fun;

    HelloWorld() {
        using std::placeholders::_1;
        using std::placeholders::_2;
        _methods["HelloWorld.hello"] = std::bind(&HelloWorld::hello, this, _1, _2);
        _methods["HelloWorld.world"] = std::bind(&HelloWorld::world, this, _1, _2);
    }

    virtual ~HelloWorld() {}

    virtual const char* name() const {
        return "HelloWorld";
    }

    virtual const co::map<const char*, Fun>& methods() const {
        return _methods;
    }

    virtual void hello(Json& req, Json& res) = 0;

    virtual void world(Json& req, Json& res) = 0;

  private:
    co::map<const char*, Fun> _methods;
};

} // xx
```

- 可以看到，HelloWorld 类继承于 rpc::Service，它已经实现了 rpc::Service 中的 name() 与 methods() 方法。
- 用户只需要继承 HelloWorld 类，实现 hello 与 world 两个方法即可。



### 业务实现

```cpp
#include "hello_world.h"

namespace xx {

class HelloWorldImpl : public HelloWorld {
  public:
    HelloWorldImpl() = default;
    virtual ~HelloWorldImpl() = default;

    virtual void hello(Json& req, Json& res) {
        res = {
            { "result", {
                { "hello", 23 }
            }}
        };
    }

    virtual void world(Json& req, Json& res) {
        res = {
            { "error", "not supported"}
        };
    }
};

} // xx
```

- 上面只是一个很简单的例子，实际应用中，一般需要根据 req 中的参数，进行相应的业务处理，然后填充 res。



### 启动 RPC server

```cpp
int main(int argc, char** argv) {
    flag::init(argc, argv);

    rpc::Server()
        .add_service(new xx::HelloWorldImpl)
        .start("127.0.0.1", 7788, "/xx");

    for (;;) sleep::sec(80000);
    return 0;
}
```

- 启动 server 前，需要先调用 add_service() 添加 service。
- `start()` 方法不会阻塞当前线程，因此需要写一个 for 循环，防止 main 函数直接退出。



### 用 curl 调用 RPC 服务

在 v3.0 版本中，co/rpc 支持 HTTP 协议，因此可以用 `curl` 命令调用 RPC 服务：

```bash
curl http://127.0.0.1:7788/xx --request POST --data '{"api":"ping"}'
curl http://127.0.0.1:7788/xx --request POST --data '{"api":"HelloWorld.hello"}'
```

- 上面用 curl 给 RPC 服务发送 POST 请求，参数为 JSON 字符串，需要提供一个 `"api"` 字段，指明调用的 RPC 方法。

- `"ping"` 是 RPC 框架内置的方法，一般用于测试或发送心跳。

- url 中 `/xx` 要与 RPC server 启动时指定的 url 保持一致。




## rpc::Client

### Client::Client

```cpp
Client(const char* ip, int port, bool use_ssl=false);
Client(const Client& c);
```

- 构造函数。
- 第一个版本中，参数 ip 是服务器的 ip，可以是域名、IPv4 或 IPv6 地址；参数 port 是服务器端口；参数 use_ssl 表示是否启用 SSL 传输，默认为 false，不启用 SSL。
- 第二个版本是拷贝构造函数。
- **rpc::Client 构建时，并没有立即建立连接**。



### Client::~Client

```cpp
Client::~Client();
```

- 析构函数，关闭连接。



### Client::call

```cpp
void call(const Json& req, Json& res);
```

- 执行 RPC 请求，必须在协程中调用。
- 参数 `req` 中必须带有 `"api"` 字段，该字段的值一般为 `"service.method"` 形式。
- 参数 `res` 是 RPC 请求的响应结果。
- 若 RPC 请求没有发送出去，或者没有收到服务端的响应，res 将不会被填充。
- 此方法在发送 RPC 请求前，会检查连接状态，未连接时，先建立连接。



### Client::close

```cpp
void close();
```

- 关闭连接，多次调用此函数是安全的。



### Client::ping

```cpp
void ping();
```

- 给 rpc::Server 发送 `ping` 请求，一般用于测试或发送心跳。




## RPC client 示例

### 直接使用 rpc::Client

```cpp
DEF_bool(use_ssl, false, "use ssl if true");
DEF_int32(n, 3, "request num");

void client_fun() {
    rpc::Client c("127.0.0.1", 7788, FLG_use_ssl);

    for (int i = 0; i < FLG_n; ++i) {
        Json req = {
            {"api", "HelloWorld.hello"}
        };
        Json res;
        c.call(req, res);
        co::sleep(1000);
    }

    c.close();
}

go(client_fun);
```

- 上面的例子中，client 每隔 1 秒向服务端发送一个 RPC 请求。



### 使用连接池 co::Pool

当客户端需要建立大量连接时，可以用 `co::Pool` 管理这些连接。

```cpp
std::unique_ptr<rpc::Client> proto;

co::Pool pool(
    []() { return (void*) new rpc::Client(*proto); },
    [](void* p) { delete (rpc::Client*) p; }
);

void client_fun() {
    co::PoolGuard<rpc::Client> c(pool);

    while (true) {
        c->ping();
        co::sleep(3000);
    }
}

proto.reset(new rpc::Client("127.0.0.1", 7788));

for (int i = 0; i < 8; ++i) {
    go(client_fun);
}
```

- 上面的例子，使用 co::Pool 保存客户端，多个协程可以共享这些客户端。
- co::PoolGuard 创建时自动从 co::Pool 中取出一个空闲的客户端，析构时自动将该客户端放回 co::Pool。
- co::Pool 的 ccb 利用拷贝构造的方式从 proto 复制一个客户端。




## 配置项

co/rpc 使用 [co/flag](../../flag/) 定义配置项，下面列出的是 co/rpc 内部定义的 flag。


### rpc_conn_idle_sec

```cpp
DEF_int32(rpc_conn_idle_sec, 180, "#2 connection may be closed if no data...");
```

- rpc::Server 空闲连接超时时间，单位为秒。一个连接在此时间内没有收到任何数据，server 可能会关闭此连接。



### rpc_conn_timeout

```cpp
DEF_int32(rpc_conn_timeout, 3000, "#2 connect timeout in ms");
```

- rpc::Client 连接超时时间，单位为毫秒。



### rpc_log

```cpp
DEF_bool(rpc_log, true, "#2 enable rpc log if true");
```

- 是否打印 RPC 日志，默认为 true，rpc::Server 与 rpc::Client 会打印 RPC 请求与响应。



### rpc_max_idle_conn

```cpp
DEF_int32(rpc_max_idle_conn, 128, "#2 max idle connections");
```

- rpc::Server 最大空闲连接数，默认为 128，超过这个数量时，server 会关闭部分空闲连接。



### rpc_max_msg_size

```cpp
DEF_int32(rpc_max_msg_size, 8 << 20, "#2 max size of rpc message, default: 8M");
```

- RPC 消息的最大长度，默认为 8M。



### rpc_recv_timeout

```cpp
DEF_int32(rpc_recv_timeout, 3000, "#2 recv timeout in ms");
```

- RPC 接收超时时间，单位为毫秒。



### rpc_send_timeout

```cpp
DEF_int32(rpc_send_timeout, 3000, "#2 send timeout in ms");
```

- RPC 发送超时时间，单位为毫秒。
